\section{Computing $\BLap(\Phi)$}
In this section, we propose an Whitening-based Algorithm to compute an approximation $\BLap(\Phi)$ of backbone.
Whitening algorithm was proposed in \cite{Par03} for the coloring problem of random graphs, which identify nodes that always have the same color in all legal colorings. It was well-known that SAT problem can be transformed into coloring problem, vice versa.
Therefore, the Whitening algorithm could be used to compute literals that should have same value in all the models.
If the under-approximation $\NBLap(\Phi)$ of non-backbone contains at least one literal, 
then, we can find all the non-backbone literals, as well as backbone literals.
However, 


 
 originated from the coloring problem of graphs. Some non-backbone literals are removed from the result of Whitening Algorithm using heuristic strategy.


 We apply Whitening Algorithm to compute the approximation of backbone and remove part of the non-backbone literals using dependency structure of a formula.

 Whitening Algorithm was proposed in \cite{CJG2001} originated from the coloring problem of graphs. A dependency structure is a directed graph that describes the neighbour relationship between literals. The literals are the vertexes in the graph. For two literals that in the same clause, there is an edge between, for a pair of negation literals $l$ and $\neg l$, there is an edge between them. For unit clauses, there is a circle edge that pointed back to the literal itself.

 Intuitively, the literals in unit clauses are backbone literals. Therefore, literals with a circle edge is a backbone literal.

 Whitening Algorithm will mark some clauses as whitening clauses. A literal is added to the approximation of non-backbone literals if all clauses that containing it is a whitening clause. If a clauses contains at least one literal or its negation in the approximation of non-backbone literals, the clauses is marked as Whitening Clause. The underlying intuition is that if a literal is in the approximation of non-backbone literals, then a new model will generated by negating the assignment of the literal. In the newly generated model, the negation of the literal must also be in the approximation of non-backbone literals because of the existence of the original model. Therefore, if a clause is marked as Whitening clause, it won't be the obstacle of a literal being an element of the approximation of non-backbone literals.

 Since we use the dependency graph to discover the potential non-backbone literals, it's no need to explore the paths that containing a Whitening clause. We remove edges which labels containing Whitening clause and simply the graph.

 We search for the paths that starting from a literal $l$, ending at $\neg l$ with a length larger than 2. If every literal at the $2k_{th}$ position is the negation of the literal at $2k+1_{th}$ position, expect for the starting and ending literal, k starts from 1, then we possibly can generate a new model by negating the assignments of every literals on the path, refereed as \emph{rotate path}. However, if no such paths found, no models can be generated by negating the assignment of the given literal.

  Since Whitening Algorithm computes the approximation of non-backbone literals, we initialized $\BLap$ by removing the result of Whitening Algorithms from $\Lit(\Phi)$, i.e., $\BLap:=\Lit(\Phi)\setminus{\sf Whitening(\Phi,\NBLap)}$.
   

\begin{algorithm}
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}
\SetAlgoShortEnd
\SetFillComment
\Input{$\Phi$: a formula, $\NBLap$: under-approximation of non-backbone}
\Output{$\BLap(\Phi)$: backbone approximation of $\Phi$}


%$\NBC=\HDBS(\Phi)=\emptyset$\;
%$\NBL_e=\NBL_u$\;
%$(b,\lambda)=\SAT(\Phi$)\;
%\lIf{$b==0$} \Return $\Lit(\Phi)$\;
%\For{$\phi\in\Phi$}{
 %   $\NBC = \NBC\cup\{\phi\in\Phi \mid \exists x\in\phi, x\in\NBL_u\}$\;
 %  $\NBL_e(\Phi)=\NBL_e(\Phi)\cup \{x\in\Lit(\Phi) \mid \forall\phi\in\Phi: \lambda(x)\models\phi\Longrightarrow\phi\in\NBC\}$\;
%}
%\Repeat{No Update of $\NBL_e$}{
 %   $\NBC = \NBC \cup \{\phi\in\Phi\setminus\NBC \mid \exists x\in\NBL_e(\Phi)\vee\exists\neg x\in\NBL_e, x\in\Lit(\phi)\}$\;
 %   $\NBL_e(\Phi) = \NBL_e(\Phi) \cup \{x\in \Lit(\Phi) \mid \forall\phi\in\Phi: \lambda(x)\models\phi\Longrightarrow\phi\in\Psi\}$\;
%}
$\BLap:=\Lit(\Phi)\setminus{\textsf{Whitening}}(\Phi,\NBLap)$\;
\For{$x\in\BLap(\Phi)$}{
    $k:=1$\;
    $\Phi_{x}^0:=\{x\}$\;
    \Repeat {$\Phi_{l_x}^k:=\Phi$}{
        $\Phi_{x}^k:=\{\phi\in\Phi \mid \neg\Lit(\Phi_{x}^{k-1})\in\phi\}$\;
        \If{$\neg x\in\Lit(\Phi_{x}^k)$}{
                $\BLap(\Phi):=\BLap(\Phi)\setminus\{x\}$\;
                break\;
        }
        k++\;
    }
}
\Return $\BLap(\Phi)$\;
\caption{Backbones approximation of $\Phi$}
\label{alg:nBLo}
\end{algorithm}
 